import { Injectable, Logger } from "@nestjs/common";
import { DataIngestionService } from "../data-ingestion/data-ingestion.service";
import { AnalysisEngineService } from "../analysis-engine/analysis-engine.service";
import { MlPredictionService } from "../ml-prediction/ml-prediction.service";
import { PrismaService } from "../persistence/prisma.service";
import { PortfolioService } from "../portfolio/portfolio.service";
import { BacktestService } from "../portfolio/backtest.service";
import { RiskManagementService } from "../portfolio/risk-management.service";
import { PredictionResult } from "../common/types";

@Injectable()
export class SimpleCliService {
  private readonly logger = new Logger(SimpleCliService.name);
  private persistentMode = false;
  private backgroundTrainingInterval?: NodeJS.Timeout;

  constructor(
    private readonly dataIngestionService: DataIngestionService,
    private readonly analysisEngineService: AnalysisEngineService,
    private readonly mlPredictionService: MlPredictionService,
    private readonly prismaService: PrismaService,
    private readonly portfolioService: PortfolioService,
    private readonly backtestService: BacktestService,
    private readonly riskManagementService: RiskManagementService,
  ) {}

  async processCommand(args: string[]): Promise<void> {
    const command = args[2]; // node script.js <command>

    try {
      switch (command) {
        case "status":
          await this.handleStatusCommand();
          break;
        case "track":
          await this.handleTrackCommand(args[3]);
          break;
        case "predict":
          await this.handlePredictCommand(args[3]);
          break;
        case "train":
          await this.handleTrainCommand();
          break;
        case "train-start":
          await this.handleTrainStartCommand();
          break;
        case "train-stop":
          await this.handleTrainStopCommand();
          break;
        case "train-status":
          await this.handleTrainStatusCommand();
          break;
        case "list":
          await this.handleListCommand();
          break;
        case "portfolio-create":
          await this.handlePortfolioCreateCommand(args[3]);
          break;
        case "portfolio-list":
          await this.handlePortfolioListCommand();
          break;
        case "portfolio-add":
          await this.handlePortfolioAddPositionCommand(
            args[3],
            args[4],
            parseFloat(args[5] || "1"),
          );
          break;
        case "portfolio-remove":
          await this.handlePortfolioRemovePositionCommand(args[3], args[4]);
          break;
        case "portfolio-analyze":
          await this.handlePortfolioAnalyzeCommand(args[3]);
          break;
        case "backtest":
          await this.handleBacktestCommand(args[3], args[4], args[5]);
          break;
        case "risk-analysis":
          await this.handleRiskAnalysisCommand(args[3]);
          break;
        case "persistent-start":
          await this.startPersistentMode();
          break;
        case "persistent-stop":
          await this.stopPersistentMode();
          break;
        case "dashboard":
          await this.handleDashboardCommand();
          break;
        default:
          this.showHelp();
      }
    } catch (error) {
      this.logger.error(`Fehler beim Ausf√ºhren des Befehls ${command}:`, error);
      process.exit(1);
    }
  }

  private async handleStatusCommand(): Promise<void> {
    console.log("üöÄ KAIROS Stock Analysis CLI - Status");
    console.log("=====================================");

    try {
      const stockCount = await this.prismaService.stock.count();
      const dataPointsCount = await this.prismaService.historicalData.count();

      console.log(`üìä Verfolgte Aktien: ${stockCount}`);
      console.log(`üìà Datenpunkte: ${dataPointsCount}`);

      if (stockCount > 0) {
        const latestData = await this.prismaService.historicalData.findFirst({
          orderBy: { timestamp: "desc" },
          include: { stock: true },
        });

        if (latestData) {
          console.log(
            `üïê Neueste Daten: ${latestData.stock.ticker} (${latestData.timestamp.toLocaleDateString()})`,
          );
        }
      }

      console.log("‚úÖ System ist bereit");
    } catch (error) {
      console.log("‚ùå Fehler beim Abrufen des Status");
      throw error;
    }
  }

  private async handleTrackCommand(ticker: string): Promise<void> {
    if (!ticker) {
      console.log("‚ùå Bitte geben Sie ein Ticker-Symbol an: kairos track AAPL");
      return;
    }

    console.log(`üéØ F√ºge ${ticker} zur Verfolgung hinzu...`);

    try {
      const existingStock = await this.prismaService.stock.findUnique({
        where: { ticker: ticker.toUpperCase() },
      });

      if (existingStock) {
        console.log(`‚ö†Ô∏è  ${ticker} wird bereits verfolgt`);
        return;
      } // Aktie zur Datenbank hinzuf√ºgen
      await this.dataIngestionService.addNewStock(ticker.toUpperCase());
      // Historische Daten abrufen
      console.log("üì• Lade historische Daten...");
      await this.dataIngestionService.fetchHistoricalDataForStock(
        ticker.toUpperCase(),
      );

      console.log(`‚úÖ ${ticker} wurde erfolgreich hinzugef√ºgt`);
    } catch (error) {
      console.log(`‚ùå Fehler beim Hinzuf√ºgen von ${ticker}`);
      throw error;
    }
  }

  private async handlePredictCommand(ticker: string): Promise<void> {
    if (!ticker) {
      console.log(
        "‚ùå Bitte geben Sie ein Ticker-Symbol an: kairos predict AAPL",
      );
      return;
    }

    console.log(`üîÆ Erstelle Prognose f√ºr ${ticker}...`);

    try {
      const stock = await this.prismaService.stock.findUnique({
        where: { ticker: ticker.toUpperCase() },
      });

      if (!stock) {
        console.log(
          `‚ùå ${ticker} wird nicht verfolgt. F√ºgen Sie es zuerst hinzu: kairos track ${ticker}`,
        );
        return;
      } // Aktuelle Daten abrufen
      await this.dataIngestionService.fetchLatestDataForStock(
        ticker.toUpperCase(),
      );

      // Prognose erstellen
      const prediction = await this.mlPredictionService.predictNext(
        ticker.toUpperCase(),
      );

      if (prediction) {
        console.log("\nüìä Prognose-Ergebnis:");
        console.log("====================");
        console.log(`üéØ Aktie: ${ticker.toUpperCase()}`);
        console.log(
          `üé≤ Konfidenz: ${(prediction.confidence * 100).toFixed(1)}%`,
        );
        console.log(
          `üíπ Prognostizierte Richtung: ${prediction.direction > 0 ? "üìà Aufw√§rts" : "üìâ Abw√§rts"}`,
        );
        console.log(`üïê Zeitstempel: ${prediction.timestamp.toLocaleString()}`);

        if (prediction.targetPrice) {
          console.log(
            `üí∞ Prognostizierter Preis: $${prediction.targetPrice.toFixed(2)}`,
          );
        }

        console.log("\n‚ö†Ô∏è  Disclaimer: Dies ist keine Anlageberatung!");
      } else {
        console.log("‚ùå Keine Prognose m√∂glich - nicht gen√ºgend Daten");
      }
    } catch (error) {
      console.log(`‚ùå Fehler bei der Prognose f√ºr ${ticker}`);
      throw error;
    }
  }

  private async handleTrainCommand(): Promise<void> {
    console.log("üß† Starte ML-Modell Training...");

    try {
      await this.mlPredictionService.trainModel();
      console.log("‚úÖ ML-Modell erfolgreich trainiert");
    } catch (error) {
      console.log("‚ùå Fehler beim Training des ML-Modells");
      throw error;
    }
  }

  private async handleTrainStartCommand(): Promise<void> {
    if (!this.persistentMode) {
      console.log("üß† Starte erweiteres ML-Modell Training...");
      console.log("üí° Verwenden Sie 'kairos train-stop' zum sicheren Beenden");
      console.log("üí° Verwenden Sie 'kairos train-status' f√ºr Status-Updates");

      try {
        const success = await this.mlPredictionService.startTraining();
        if (success) {
          console.log("‚úÖ ML-Modell erfolgreich trainiert");
        } else {
          console.log("‚ö†Ô∏è Training wurde abgebrochen oder fehlgeschlagen");
        }
      } catch (error) {
        console.log("‚ùå Fehler beim Training des ML-Modells");
        throw error;
      }
      return;
    }

    // Persistenter Modus
    const trainingStatus = this.mlPredictionService.getTrainingStatus();
    if (trainingStatus.isTraining) {
      console.log("‚ö†Ô∏è Training l√§uft bereits im Hintergrund");
      console.log(
        "üí° Verwenden Sie 'train-status' f√ºr Details oder 'train-stop' zum Beenden",
      );
      return;
    }

    console.log("üß† Starte Hintergrund-Training...");
    console.log("üí° Das Training l√§uft im Hintergrund. CLI bleibt verf√ºgbar.");
    console.log(
      "üí° Verwenden Sie 'train-status' f√ºr Updates oder 'train-stop' zum Beenden",
    );

    try {
      // Training im Hintergrund starten (non-blocking)
      this.mlPredictionService
        .startTraining()
        .then((success) => {
          if (success) {
            console.log("\n‚úÖ Hintergrund-Training erfolgreich abgeschlossen");
          } else {
            console.log("\n‚ö†Ô∏è Hintergrund-Training wurde abgebrochen");
          }
          console.log("kairos> "); // Prompt wiederherstellen
        })
        .catch((error) => {
          console.log("\n‚ùå Fehler beim Hintergrund-Training:", error.message);
          console.log("kairos> "); // Prompt wiederherstellen
        });

      // Kurz warten und ersten Status zeigen
      setTimeout(() => {
        const status = this.mlPredictionService.getTrainingStatus();
        if (status.isTraining) {
          console.log("üü¢ Hintergrund-Training gestartet");
        }
      }, 1000);
    } catch (error) {
      console.log("‚ùå Fehler beim Starten des Hintergrund-Trainings");
      throw error;
    }
  }

  private async handleTrainStopCommand(): Promise<void> {
    const trainingStatus = this.mlPredictionService.getTrainingStatus();

    if (!trainingStatus.isTraining) {
      console.log("‚ö†Ô∏è Kein Training l√§uft derzeit");
      return;
    }

    if (this.persistentMode) {
      console.log("üõë Beende Hintergrund-Training...");
    } else {
      console.log("üõë Beende Training sicher...");
    }

    try {
      const success = await this.mlPredictionService.stopTraining();
      if (success) {
        console.log("‚úÖ Training wurde sicher beendet");
      } else {
        console.log("‚ö†Ô∏è Kein Training l√§uft derzeit");
      }
    } catch (error) {
      console.log("‚ùå Fehler beim Beenden des Trainings");
      throw error;
    }
  }

  private async handleTrainStatusCommand(): Promise<void> {
    console.log("üìä Training Status:");
    console.log("==================");

    try {
      const status = this.mlPredictionService.getTrainingStatus();

      if (!status.isTraining) {
        console.log("üî¥ Kein Training l√§uft derzeit");
        console.log(
          "üí° Verwenden Sie 'kairos train-start' um Training zu starten",
        );
        return;
      }

      console.log("üü¢ Training l√§uft...");

      if (status.startTime) {
        const runningTime = Date.now() - status.startTime.getTime();
        const runningMinutes = Math.floor(runningTime / 60000);
        const runningSeconds = Math.floor((runningTime % 60000) / 1000);
        console.log(`üïê Laufzeit: ${runningMinutes}m ${runningSeconds}s`);
      }

      if (status.currentEpoch && status.totalEpochs) {
        const progress = (
          (status.currentEpoch / status.totalEpochs) *
          100
        ).toFixed(1);
        console.log(
          `üìà Fortschritt: ${status.currentEpoch}/${status.totalEpochs} (${progress}%)`,
        );
      }

      if (status.loss !== undefined) {
        console.log(`üíî Loss: ${status.loss.toFixed(4)}`);
      }

      if (status.accuracy !== undefined) {
        console.log(`üéØ Accuracy: ${(status.accuracy * 100).toFixed(2)}%`);
      }

      console.log(
        "\nüí° Verwenden Sie 'kairos train-stop' zum sicheren Beenden",
      );
    } catch (error) {
      console.log("‚ùå Fehler beim Abrufen des Training-Status");
      throw error;
    }
  }

  private async handleListCommand(): Promise<void> {
    console.log("üìã Verfolgte Aktien:");
    console.log("===================");

    try {
      const stocks = await this.prismaService.stock.findMany({
        orderBy: { ticker: "asc" },
      });

      if (stocks.length === 0) {
        console.log("üì≠ Keine Aktien werden verfolgt");
        console.log(
          'üí° Verwenden Sie "kairos track <TICKER>" um eine Aktie hinzuzuf√ºgen',
        );
        return;
      }

      for (const stock of stocks) {
        // Neueste Daten f√ºr jede Aktie abrufen
        const latestData = await this.prismaService.historicalData.findFirst({
          where: { stockId: stock.id },
          orderBy: { timestamp: "desc" },
        });

        const price = latestData ? `$${latestData.close.toFixed(2)}` : "N/A";
        const date = latestData
          ? latestData.timestamp.toLocaleDateString()
          : "N/A";

        console.log(
          `üìà ${stock.ticker.padEnd(6)} | ${stock.name.padEnd(30)} | ${price.padStart(10)} | ${date}`,
        );
      }
    } catch (error) {
      console.log("‚ùå Fehler beim Auflisten der Aktien");
      throw error;
    }
  }

  private showHelp(): void {
    console.log("üéØ KAIROS - KI-gest√ºtzte Aktienanalyse");
    console.log("=====================================");
    console.log("");
    console.log("üìä GRUNDLEGENDE BEFEHLE:");
    console.log("  status               - System-Status anzeigen");
    console.log("  dashboard            - √úbersicht aller Daten");
    console.log("  list                 - Alle verfolgten Aktien auflisten");
    console.log("  track <TICKER>       - Aktie zur Verfolgung hinzuf√ºgen");
    console.log("");
    console.log("ü§ñ ML-VORHERSAGEN:");
    console.log("  predict <TICKER>     - Preis-Vorhersage f√ºr Aktie");
    console.log("  train                - Einmaliges ML-Training starten");
    console.log("  train-start          - Kontinuierliches Training starten");
    console.log("  train-stop           - Training beenden");
    console.log("  train-status         - Training-Status anzeigen");
    console.log("");
    console.log("üíº PORTFOLIO-MANAGEMENT:");
    console.log(
      "  portfolio-create <NAME>                    - Neues Portfolio erstellen",
    );
    console.log(
      "  portfolio-list                             - Alle Portfolios auflisten",
    );
    console.log(
      "  portfolio-add <ID> <TICKER> <QUANTITY>     - Position hinzuf√ºgen",
    );
    console.log(
      "  portfolio-remove <ID> <TICKER>             - Position entfernen",
    );
    console.log(
      "  portfolio-analyze <ID>                     - Portfolio analysieren",
    );
    console.log("");
    console.log("üìà BACKTESTING & RISIKO:");
    console.log(
      "  backtest <STRATEGY> <START> <END>         - Backtest durchf√ºhren",
    );
    console.log("  risk-analysis <PORTFOLIO_ID>              - Risiko-Analyse");
    console.log("");
    console.log("üîß SYSTEM:");
    console.log("  persistent-start     - Kontinuierlichen Modus starten");
    console.log("  persistent-stop      - Kontinuierlichen Modus beenden");
    console.log("");
    console.log("üìã BEISPIELE:");
    console.log("  kairos track AAPL");
    console.log("  kairos predict AAPL");
    console.log("  kairos portfolio-create 'Mein Portfolio'");
    console.log("  kairos backtest rsi 2024-01-01 2024-12-31");
    console.log("");
    console.log("üí° Verf√ºgbare Strategien: rsi, sma, macd");

    if (this.persistentMode) {
      console.log("");
      console.log("üîÑ Persistenter Modus aktiv - CLI bleibt ge√∂ffnet");
      console.log("üí° Verwenden Sie 'exit' oder 'quit' zum Beenden");
    }
  }

  /**
   * Startet den persistenten CLI-Modus
   */
  async startPersistentMode(): Promise<void> {
    this.persistentMode = true;
    this.logger.log("üîÑ Persistenter CLI-Modus aktiviert");

    // Hintergrund-Training-Status-Updates starten
    this.startBackgroundStatusUpdates();
  }

  /**
   * Stoppt den persistenten CLI-Modus
   */
  async stopPersistentMode(): Promise<void> {
    this.persistentMode = false;

    // Hintergrund-Updates stoppen
    if (this.backgroundTrainingInterval) {
      clearInterval(this.backgroundTrainingInterval);
      this.backgroundTrainingInterval = undefined;
    }

    // Laufendes Training sicher beenden
    const trainingStatus = this.mlPredictionService.getTrainingStatus();
    if (trainingStatus.isTraining) {
      console.log("üõë Beende laufendes Training...");
      await this.mlPredictionService.stopTraining();
    }

    this.logger.log("üîÑ Persistenter CLI-Modus deaktiviert");
  }

  /**
   * Startet Hintergrund-Status-Updates f√ºr Training
   */
  private startBackgroundStatusUpdates(): void {
    this.backgroundTrainingInterval = setInterval(() => {
      const status = this.mlPredictionService.getTrainingStatus();

      if (status.isTraining && this.persistentMode) {
        // Status-Update in der Konsole (ohne neue Zeile zu st√∂ren)
        const progress =
          status.currentEpoch && status.totalEpochs
            ? `${status.currentEpoch}/${status.totalEpochs}`
            : "N/A";

        const loss = status.loss !== undefined ? status.loss.toFixed(4) : "N/A";
        const accuracy =
          status.accuracy !== undefined
            ? (status.accuracy * 100).toFixed(2) + "%"
            : "N/A";

        // Zeige Status in der gleichen Zeile an (√ºberschreibt vorherige)
        process.stdout.write(
          `\rüß† Training: ${progress} | Loss: ${loss} | Acc: ${accuracy} | Eingabe: `,
        );
      }
    }, 2000); // Update alle 2 Sekunden
  }

  /**
   * Portfolio-Management Commands
   */
  private async handlePortfolioCreateCommand(name: string): Promise<void> {
    if (!name) {
      console.log("‚ùå Portfolio-Name ist erforderlich");
      console.log("üí° Verwendung: portfolio-create <NAME>");
      return;
    }

    try {
      const portfolio = await this.portfolioService.createPortfolioWithCapital(
        name,
        10000,
      ); // Default: $10,000
      console.log("‚úÖ Portfolio erstellt:");
      console.log(`üìä Name: ${portfolio.name}`);
      console.log(
        `üí∞ Startkapital: $${(portfolio.initialValue || 0).toFixed(2)}`,
      );
      console.log(`üÜî ID: ${portfolio.id}`);
    } catch (error) {
      console.log("‚ùå Fehler beim Erstellen des Portfolios");
      this.logger.error("Fehler beim Erstellen des Portfolios", error);
    }
  }

  private async handlePortfolioListCommand(): Promise<void> {
    try {
      const portfolios = await this.portfolioService.getAllPortfolios();

      if (portfolios.length === 0) {
        console.log("üìã Keine Portfolios gefunden");
        console.log(
          "üí° Erstellen Sie ein Portfolio mit: portfolio-create <NAME>",
        );
        return;
      }

      console.log("üìã Ihre Portfolios:");
      console.log("===================");

      for (const portfolio of portfolios) {
        const metrics =
          await this.portfolioService.calculatePortfolioMetrics(portfolio);
        const positionCount = portfolio.positions.length;

        console.log(
          `üìä ${portfolio.name} (${portfolio.id.substring(0, 8)}...)`,
        );
        console.log(`   üí∞ Aktueller Wert: $${metrics.totalValue.toFixed(2)}`);
        console.log(
          `   üìà Rendite: ${(metrics.totalReturn * 100).toFixed(2)}%`,
        );
        console.log(`   üìã Positionen: ${positionCount}`);
        console.log(
          `   üìÖ Erstellt: ${portfolio.createdAt.toLocaleDateString()}`,
        );
        console.log("");
      }
    } catch (error) {
      console.log("‚ùå Fehler beim Abrufen der Portfolios");
      this.logger.error("Fehler beim Abrufen der Portfolios", error);
    }
  }

  private async handlePortfolioAddPositionCommand(
    portfolioId: string,
    ticker: string,
    quantity: number,
  ): Promise<void> {
    if (!portfolioId || !ticker || !quantity) {
      console.log("‚ùå Portfolio-ID, Ticker und Anzahl sind erforderlich");
      console.log(
        "üí° Verwendung: portfolio-add <PORTFOLIO_ID> <TICKER> <QUANTITY>",
      );
      return;
    }

    try {
      // Pr√ºfe ob Aktie verfolgt wird
      const stock = await this.prismaService.stock.findUnique({
        where: { ticker: ticker.toUpperCase() },
      });

      if (!stock) {
        console.log(`‚ùå Aktie ${ticker.toUpperCase()} wird nicht verfolgt`);
        console.log(
          `üí° F√ºgen Sie die Aktie zuerst hinzu: track ${ticker.toUpperCase()}`,
        );
        return;
      }

      // Aktuellen Preis abrufen
      const latestData = await this.prismaService.historicalData.findFirst({
        where: { stockId: stock.id },
        orderBy: { timestamp: "desc" },
      });

      if (!latestData) {
        console.log(
          `‚ùå Keine Preisdaten f√ºr ${ticker.toUpperCase()} verf√ºgbar`,
        );
        return;
      }

      const position = await this.portfolioService.addPosition(
        portfolioId,
        ticker.toUpperCase(),
        quantity,
        latestData.close,
      );

      console.log("‚úÖ Position hinzugef√ºgt:");
      console.log(`üìä Portfolio: ${portfolioId.substring(0, 8)}...`);
      console.log(
        `üìà ${ticker.toUpperCase()}: ${quantity} Aktien @ $${latestData.close.toFixed(2)}`,
      );
      console.log(
        `üí∞ Gesamtwert: $${(quantity * latestData.close).toFixed(2)}`,
      );
    } catch (error) {
      console.log("‚ùå Fehler beim Hinzuf√ºgen der Position");
      this.logger.error("Fehler beim Hinzuf√ºgen der Position", error);
    }
  }

  private async handlePortfolioRemovePositionCommand(
    portfolioId: string,
    ticker: string,
  ): Promise<void> {
    if (!portfolioId || !ticker) {
      console.log("‚ùå Portfolio-ID und Ticker sind erforderlich");
      console.log("üí° Verwendung: portfolio-remove <PORTFOLIO_ID> <TICKER>");
      return;
    }

    try {
      await this.portfolioService.removePosition(
        portfolioId,
        ticker.toUpperCase(),
      );
      console.log("‚úÖ Position entfernt:");
      console.log(`üìä Portfolio: ${portfolioId.substring(0, 8)}...`);
      console.log(`‚ùå ${ticker.toUpperCase()} Position geschlossen`);
    } catch (error) {
      console.log("‚ùå Fehler beim Entfernen der Position");
      this.logger.error("Fehler beim Entfernen der Position", error);
    }
  }

  private async handlePortfolioAnalyzeCommand(
    portfolioId: string,
  ): Promise<void> {
    if (!portfolioId) {
      console.log("‚ùå Portfolio-ID ist erforderlich");
      console.log("üí° Verwendung: portfolio-analyze <PORTFOLIO_ID>");
      return;
    }

    try {
      const portfolio = await this.portfolioService.getPortfolio(portfolioId);
      if (!portfolio) {
        console.log("‚ùå Portfolio nicht gefunden");
        return;
      }

      const metrics =
        await this.portfolioService.calculatePortfolioMetrics(portfolio);

      // Standard-Risiko-Limits definieren
      const riskLimits = {
        maxPositionSize: 20.0, // 20% max position size
        maxSectorExposure: 30.0, // 30% max sector exposure
        maxDrawdown: 15.0, // 15% max drawdown
        minLiquidity: 5.0, // 5% minimum cash
        maxLeverage: 1.0, // No leverage
        maxCorrelation: 0.7, // 70% max correlation
        stopLossLevel: 10.0, // 10% stop loss
      };

      const riskAssessment =
        await this.riskManagementService.assessPortfolioRisk(
          portfolio,
          riskLimits,
        );

      console.log(`üìä Portfolio-Analyse: ${portfolio.name}`);
      console.log("========================================");
      console.log("");

      console.log("üí∞ Performance-Metriken:");
      console.log(`   Gesamtwert: $${metrics.totalValue.toFixed(2)}`);
      console.log(
        `   Tagesrendite: ${(metrics.dailyReturn * 100).toFixed(2)}%`,
      );
      console.log(
        `   Gesamtrendite: ${(metrics.totalReturn * 100).toFixed(2)}%`,
      );
      console.log(`   Sharpe Ratio: ${metrics.sharpeRatio.toFixed(2)}`);
      console.log(
        `   Max Drawdown: ${(metrics.maxDrawdown * 100).toFixed(2)}%`,
      );
      console.log(`   Volatilit√§t: ${(metrics.volatility * 100).toFixed(2)}%`);
      console.log("");

      console.log("‚ö†Ô∏è Risiko-Bewertung:");
      console.log(`   Risiko-Level: ${riskAssessment.riskLevel}`);
      console.log(`   Risiko-Score: ${riskAssessment.riskScore}/100`);
      console.log("");

      if (riskAssessment.alerts.length > 0) {
        console.log("üö® Risiko-Warnungen:");
        riskAssessment.alerts.forEach((alert) => {
          console.log(`   ${alert.severity}: ${alert.message}`);
        });
        console.log("");
      }

      if (riskAssessment.recommendations.length > 0) {
        console.log("üí° Empfehlungen:");
        riskAssessment.recommendations.forEach((rec) => {
          console.log(`   ‚Ä¢ ${rec}`);
        });
      }
    } catch (error) {
      console.log("‚ùå Fehler bei der Portfolio-Analyse");
      this.logger.error("Fehler bei der Portfolio-Analyse", error);
    }
  }

  private async handleBacktestCommand(
    strategy: string,
    startDate: string,
    endDate: string,
  ): Promise<void> {
    if (!strategy || !startDate || !endDate) {
      console.log("‚ùå Strategie, Start- und Enddatum sind erforderlich");
      console.log("üí° Verwendung: backtest <STRATEGY> <START_DATE> <END_DATE>");
      console.log("üí° Beispiel: backtest rsi 2024-01-01 2024-12-31");
      console.log("üí° Verf√ºgbare Strategien: rsi, sma, macd");
      return;
    }

    try {
      // Einfache vordefinierte Strategien
      const strategies: Record<string, any> = {
        rsi: {
          name: "RSI √úberverkauft/√úberkauft",
          buySignals: ["rsi_oversold"],
          sellSignals: ["rsi_overbought"],
          riskManagement: {
            stopLoss: 5.0,
            takeProfit: 10.0,
            maxPositionSize: 20.0,
          },
        },
        sma: {
          name: "Simple Moving Average Crossover",
          buySignals: ["sma_bullish_cross"],
          sellSignals: ["sma_bearish_cross"],
          riskManagement: {
            stopLoss: 3.0,
            takeProfit: 8.0,
            maxPositionSize: 25.0,
          },
        },
        macd: {
          name: "MACD Signal",
          buySignals: ["macd_bullish"],
          sellSignals: ["macd_bearish"],
          riskManagement: {
            stopLoss: 4.0,
            takeProfit: 12.0,
            maxPositionSize: 15.0,
          },
        },
      };

      const selectedStrategy = strategies[strategy.toLowerCase()];
      if (!selectedStrategy) {
        console.log(`‚ùå Unbekannte Strategie: ${strategy}`);
        console.log("üí° Verf√ºgbare Strategien: rsi, sma, macd");
        return;
      }

      const config = {
        startDate: new Date(startDate),
        endDate: new Date(endDate),
        initialCapital: 10000,
        strategy: selectedStrategy,
        riskParameters: {
          maxPositionSize: selectedStrategy.riskManagement.maxPositionSize,
          maxExposure: 80.0,
          stopLoss: selectedStrategy.riskManagement.stopLoss,
          takeProfit: selectedStrategy.riskManagement.takeProfit,
          maxDrawdown: 20.0,
        },
        tradingCosts: {
          commission: 5.0,
          spread: 0.1,
          slippage: 0.05,
        },
      };

      console.log(`üîÑ Starte Backtest f√ºr Strategie: ${selectedStrategy.name}`);
      console.log(`üìÖ Zeitraum: ${startDate} bis ${endDate}`);
      console.log(`üí∞ Startkapital: $${config.initialCapital.toFixed(2)}`);
      console.log("");

      // Alle verfolgten Aktien f√ºr Backtest holen
      const stocks = await this.prismaService.stock.findMany({
        select: { ticker: true },
      });

      if (stocks.length === 0) {
        console.log("‚ùå Keine Aktien verf√ºgbar f√ºr Backtest");
        console.log("üí° F√ºgen Sie zuerst Aktien mit 'track <TICKER>' hinzu");
        return;
      }

      const tickers = stocks.map((s) => s.ticker);
      const results = await this.backtestService.runBacktest(tickers, config);

      // Nimm das letzte Ergebnis als Gesamt-Ergebnis (Overall Performance)
      const result = results[results.length - 1];
      if (!result) {
        console.log("‚ùå Keine Backtest-Ergebnisse erhalten");
        return;
      }

      console.log("üìä Backtest-Ergebnisse:");
      console.log("========================");
      console.log(`üìà Endkapital: $${result.finalCapital.toFixed(2)}`);
      console.log(
        `üí∞ Gesamtrendite: ${(result.totalReturn * 100).toFixed(2)}%`,
      );
      console.log(`üìä Anzahl Trades: ${result.totalTrades}`);
      console.log(
        `‚úÖ Gewinn-Trades: ${result.profitableTrades} (${((result.profitableTrades / result.totalTrades) * 100).toFixed(1)}%)`,
      );
      console.log(
        `‚ùå Verlust-Trades: ${result.totalTrades - result.profitableTrades}`,
      );
      console.log(`üíî Max Drawdown: ${(result.maxDrawdown * 100).toFixed(2)}%`);
      console.log(`üìä Sharpe Ratio: ${result.sharpeRatio.toFixed(2)}`);
      console.log(`üìà Volatilit√§t: ${(result.volatility * 100).toFixed(2)}%`);
    } catch (error) {
      console.log("‚ùå Fehler beim Backtest");
      this.logger.error("Fehler beim Backtest", error);
    }
  }

  private async handleRiskAnalysisCommand(portfolioId: string): Promise<void> {
    if (!portfolioId) {
      console.log("‚ùå Portfolio-ID ist erforderlich");
      console.log("üí° Verwendung: risk-analysis <PORTFOLIO_ID>");
      return;
    }

    try {
      const portfolio = await this.portfolioService.getPortfolio(portfolioId);
      if (!portfolio) {
        console.log("‚ùå Portfolio nicht gefunden");
        return;
      }

      // Standard-Risiko-Limits definieren
      const riskLimits = {
        maxPositionSize: 20.0,
        maxSectorExposure: 30.0,
        maxDrawdown: 15.0,
        minLiquidity: 5.0,
        maxLeverage: 1.0,
        maxCorrelation: 0.7,
        stopLossLevel: 10.0,
      };

      const riskAssessment =
        await this.riskManagementService.assessPortfolioRisk(
          portfolio,
          riskLimits,
        );
      const riskMetrics =
        await this.riskManagementService.calculateRiskMetrics(portfolio);

      console.log(`‚ö†Ô∏è Risiko-Analyse: ${portfolio.name}`);
      console.log("================================");
      console.log("");

      console.log("üìä Risiko-√úbersicht:");
      console.log(`   Risiko-Level: ${riskAssessment.riskLevel}`);
      console.log(`   Risiko-Score: ${riskAssessment.riskScore}/100`);
      console.log("");

      console.log("üìà Risiko-Kennzahlen:");
      console.log(
        `   Portfolio-Risiko: ${(riskMetrics.portfolioRisk * 100).toFixed(2)}%`,
      );
      console.log(`   VaR (1 Tag, 95%): $${riskMetrics.varDaily.toFixed(2)}`);
      console.log(
        `   VaR (1 Woche, 95%): $${riskMetrics.varWeekly.toFixed(2)}`,
      );
      console.log(`   Sharpe Ratio: ${riskMetrics.sharpeRatio.toFixed(2)}`);
      console.log(`   Sortino Ratio: ${riskMetrics.sortinoRatio.toFixed(2)}`);
      console.log(
        `   Max Drawdown: ${(riskMetrics.maxDrawdown * 100).toFixed(2)}%`,
      );
      console.log(
        `   Volatilit√§t: ${(riskMetrics.volatility * 100).toFixed(2)}%`,
      );
      console.log(`   Beta: ${riskMetrics.beta.toFixed(2)}`);
      console.log(
        `   Konzentrations-Risiko: ${(riskMetrics.concentrationRisk * 100).toFixed(2)}%`,
      );
      console.log("");

      if (riskAssessment.alerts.length > 0) {
        console.log("üö® Aktive Risiko-Warnungen:");
        riskAssessment.alerts.forEach((alert) => {
          const icon =
            alert.severity === "CRITICAL"
              ? "üî¥"
              : alert.severity === "HIGH"
                ? "üü†"
                : "üü°";
          console.log(`   ${icon} ${alert.type}: ${alert.message}`);
          console.log(
            `      Wert: ${alert.value} | Grenzwert: ${alert.threshold}`,
          );
        });
        console.log("");
      }

      if (riskAssessment.recommendations.length > 0) {
        console.log("üí° Risiko-Management Empfehlungen:");
        riskAssessment.recommendations.forEach((rec) => {
          console.log(`   ‚Ä¢ ${rec}`);
        });
      }
    } catch (error) {
      console.log("‚ùå Fehler bei der Risiko-Analyse");
      this.logger.error("Fehler bei der Risiko-Analyse", error);
    }
  }

  /**
   * Dashboard Command - Zeigt System-√úbersicht
   */
  private async handleDashboardCommand(): Promise<void> {
    console.log("üéØ KAIROS Dashboard");
    console.log("===================");
    console.log("");

    try {
      // System Status
      console.log("üñ•Ô∏è System Status:");
      const trainingStatus = this.mlPredictionService.getTrainingStatus();
      if (trainingStatus.isTraining) {
        console.log("   üü¢ ML-Training l√§uft");
        if (trainingStatus.currentEpoch && trainingStatus.totalEpochs) {
          const progress = (
            (trainingStatus.currentEpoch / trainingStatus.totalEpochs) *
            100
          ).toFixed(1);
          console.log(`   üìà Fortschritt: ${progress}%`);
        }
      } else {
        console.log("   üî¥ ML-Training inaktiv");
      }
      console.log(
        `   üîÑ Persistent Mode: ${this.persistentMode ? "Aktiv" : "Inaktiv"}`,
      );
      console.log("");

      // Verfolgte Aktien
      const stocks = await this.prismaService.stock.findMany();
      console.log(`üìä Verfolgte Aktien: ${stocks.length}`);
      if (stocks.length > 0) {
        const recentStocks = stocks.slice(0, 5);
        recentStocks.forEach((stock) => {
          console.log(`   üìà ${stock.ticker} - ${stock.name}`);
        });
        if (stocks.length > 5) {
          console.log(`   ... und ${stocks.length - 5} weitere`);
        }
      }
      console.log("");

      // Portfolio-√úbersicht
      const portfolios = await this.portfolioService.getAllPortfolios();
      console.log(`üíº Portfolios: ${portfolios.length}`);
      if (portfolios.length > 0) {
        for (const portfolio of portfolios.slice(0, 3)) {
          try {
            const metrics =
              await this.portfolioService.calculatePortfolioMetrics(portfolio);
            console.log(
              `   üìä ${portfolio.name}: $${metrics.totalValue.toFixed(2)} (${(metrics.totalReturn * 100).toFixed(2)}%)`,
            );
          } catch (error) {
            console.log(
              `   üìä ${portfolio.name}: Fehler beim Laden der Metriken`,
            );
          }
        }
        if (portfolios.length > 3) {
          console.log(`   ... und ${portfolios.length - 3} weitere`);
        }
      }
      console.log("");

      // Neueste Daten
      const latestData = await this.prismaService.historicalData.findFirst({
        orderBy: { timestamp: "desc" },
        include: { stock: true },
      });

      if (latestData) {
        console.log("üìÖ Neueste Daten:");
        console.log(
          `   üìà ${latestData.stock.ticker}: $${latestData.close.toFixed(2)}`,
        );
        console.log(`   üïê ${latestData.timestamp.toLocaleDateString()}`);
      }
      console.log("");

      // Schnelle Aktionen
      console.log("üöÄ Schnelle Aktionen:");
      console.log("   ‚Ä¢ kairos track <TICKER> - Aktie hinzuf√ºgen");
      console.log("   ‚Ä¢ kairos predict <TICKER> - Vorhersage erstellen");
      console.log("   ‚Ä¢ kairos portfolio-create <NAME> - Portfolio erstellen");
      console.log("   ‚Ä¢ kairos train-start - ML-Training starten");
      console.log("   ‚Ä¢ kairos help - Alle Befehle anzeigen");
    } catch (error) {
      console.log("‚ùå Fehler beim Laden des Dashboards");
      this.logger.error("Fehler beim Dashboard", error);
    }
  }
}
